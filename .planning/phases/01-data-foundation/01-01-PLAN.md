---
phase: 01-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/ensemble/__init__.py
  - src/ensemble/__main__.py
  - src/ensemble/cli.py
  - src/ensemble/models.py
  - src/ensemble/loader.py
  - src/ensemble/slicer.py
  - tests/test_models.py
  - tests/test_slicer.py
  - tests/conftest.py
  - .env.example
  - .gitignore
autonomous: true
requirements:
  - DATA-01
  - DATA-02

must_haves:
  truths:
    - "Running `python -m ensemble load data/sample.json` prints validated EventSnapshot records with no outcome fields"
    - "Each event produces 3 time window snapshots (T-7d, T-1d, T-1h) with correct yes_price_cents per window"
    - "EventSnapshot model structurally cannot contain outcome, result, or settlement fields"
    - "Prices are stored as integer cents, never floats"
  artifacts:
    - path: "src/ensemble/models.py"
      provides: "Event, EventSnapshot, TimeWindowLabel, MarketCandle pydantic models"
      contains: "class EventSnapshot"
    - path: "src/ensemble/loader.py"
      provides: "Load events from JSON file into Event models"
      exports: ["load_events"]
    - path: "src/ensemble/slicer.py"
      provides: "Time window price extraction from candlestick data"
      exports: ["find_nearest_price", "compute_window_timestamps"]
    - path: "src/ensemble/cli.py"
      provides: "Typer CLI with load command"
      contains: "app = typer.Typer"
    - path: "tests/test_models.py"
      provides: "Schema validation and outcome exclusion tests"
    - path: "tests/test_slicer.py"
      provides: "Time window computation tests"
  key_links:
    - from: "src/ensemble/cli.py"
      to: "src/ensemble/loader.py"
      via: "load command calls load_events()"
      pattern: "load_events"
    - from: "src/ensemble/loader.py"
      to: "src/ensemble/models.py"
      via: "parses JSON into Event models"
      pattern: "Event\\("
    - from: "src/ensemble/models.py"
      to: "src/ensemble/slicer.py"
      via: "Event.snapshot() uses window_prices populated by slicer"
      pattern: "window_prices"
---

<objective>
Set up the Python project and implement the core data layer: Pydantic models (Event/EventSnapshot with composition-based type boundary), JSON file loader, time window slicer, and CLI `load` command.

Purpose: Establishes the data foundation that all subsequent phases depend on. The Event/EventSnapshot type boundary is the core research validity guarantee -- outcome data can never leak into LLM context.
Output: Working `python -m ensemble load <file>` command that loads, validates, and displays market data with time-windowed snapshots.
</objective>

<execution_context>
@/home/sohamchoulwar/.claude/get-shit-done/workflows/execute-plan.md
@/home/sohamchoulwar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/research/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding and Pydantic data models</name>
  <files>
    pyproject.toml
    .env.example
    .gitignore
    src/ensemble/__init__.py
    src/ensemble/__main__.py
    src/ensemble/models.py
    tests/conftest.py
    tests/test_models.py
  </files>
  <action>
    1. Initialize the Python project with uv:
       - Run `uv init --lib` if needed, or create pyproject.toml manually
       - Configure pyproject.toml with: name="ensemble", python=">=3.12", src layout
       - Add dependencies: pydantic>=2.6, pandas>=2.0, httpx>=0.27, typer>=0.12, rich>=13.0, python-dateutil>=2.9, openai>=1.60, python-dotenv>=1.0
       - Add dev dependencies: pytest, ruff
       - Add script entry: `[project.scripts] ensemble = "ensemble.cli:app"`
       - Run `uv sync` to install all dependencies

    2. Create .env.example with `OPENAI_API_KEY=your-key-here`

    3. Update .gitignore to include: .env, results/, __pycache__/, .ruff_cache/, *.egg-info/

    4. Create src/ensemble/__init__.py (empty or with version)

    5. Create src/ensemble/__main__.py:
       ```python
       from ensemble.cli import app
       app()
       ```

    6. Create src/ensemble/models.py with these EXACT models following the composition pattern from research:
       - `TimeWindowLabel(str, Enum)`: T_7D="T-7d", T_1D="T-1d", T_1H="T-1h"
       - `Outcome(str, Enum)`: YES="yes", NO="no"
       - `EventSnapshot(BaseModel)`: LLM-safe model with fields: event_ticker, market_ticker, title, question, description, category (all str), yes_price_cents (int), no_price_cents (int), window (TimeWindowLabel), snapshot_timestamp (datetime). Add docstring: "LLM-safe model. INVARIANT: This model NEVER contains outcome, result, settlement, or resolution data."
       - `Event(BaseModel)`: Full event with fields: event_ticker, market_ticker, series_ticker, title, question, description, category (all str), outcome (Outcome), close_time (datetime), open_time (datetime), window_prices (dict[TimeWindowLabel, int]). Include `snapshot(window)` method that creates EventSnapshot. Include `_window_timestamp(window)` helper. Add docstring warning: "Never pass this model or its outcome field to an LLM."
       - `MarketCandle(BaseModel)`: end_period_ts (datetime), close_cents (int), open_cents (int), high_cents (int), low_cents (int), volume (int)
       - CRITICAL: All prices as int (cents), never float. no_price_cents = 100 - yes_price_cents.

    7. Create tests/conftest.py with a `sample_event` fixture that returns a valid Event instance with realistic data (e.g., a Fed rate decision event with window_prices for all 3 windows).

    8. Create tests/test_models.py with tests:
       - test_event_snapshot_has_no_outcome_field: Verify EventSnapshot model fields do NOT include "outcome", "result", "settlement", "close_time", or "resolution"
       - test_event_snapshot_creation_from_event: Create Event, call .snapshot(T_7D), verify all fields populated correctly
       - test_no_price_cents_computed: Verify no_price_cents = 100 - yes_price_cents for various prices
       - test_event_snapshot_prices_are_int: Verify yes_price_cents and no_price_cents are int type
       - test_all_three_windows_produce_snapshots: Create Event with all 3 window prices, generate snapshots for each, verify different prices per window
       - test_event_validation_rejects_invalid_outcome: Verify Event rejects outcome values other than "yes"/"no"

    9. Run `uv run pytest tests/test_models.py -v` and confirm all tests pass.
  </action>
  <verify>
    `uv run pytest tests/test_models.py -v` -- all tests pass.
    `uv run python -c "from ensemble.models import Event, EventSnapshot, TimeWindowLabel; print('imports OK')"` -- prints "imports OK".
  </verify>
  <done>
    Pydantic models are defined with composition-based type boundary. EventSnapshot structurally excludes outcome data. All model tests pass. Project dependencies installed and importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: JSON file loader, time window slicer, and CLI load command</name>
  <files>
    src/ensemble/loader.py
    src/ensemble/slicer.py
    src/ensemble/cli.py
    tests/test_slicer.py
    data/sample/sample_events.json
  </files>
  <action>
    1. Create src/ensemble/slicer.py:
       - `compute_window_timestamps(close_time: datetime) -> dict[TimeWindowLabel, datetime]`: Returns timestamps for T-7d, T-1d, T-1h by subtracting timedeltas from close_time.
       - `find_nearest_price(candles: list[MarketCandle], target_ts: datetime, max_gap_hours: int = 2) -> int | None`: Finds the candlestick closest to target_ts, returns close_cents. Returns None if no candle within max_gap_hours. Uses abs(candle.end_period_ts - target_ts) comparison.
       - All datetime operations must use timezone-aware datetimes (UTC). Never strip timezone info.

    2. Create tests/test_slicer.py:
       - test_compute_window_timestamps: Verify T-7d is exactly 7 days before close, T-1d is 1 day, T-1h is 1 hour. Use timezone-aware datetime.
       - test_find_nearest_price_exact_match: Candle at exact target timestamp returns its close_cents.
       - test_find_nearest_price_within_tolerance: Candle 30 minutes from target (within 2h default) returns price.
       - test_find_nearest_price_outside_tolerance: Candle 3 hours from target (outside 2h default) returns None.
       - test_find_nearest_price_empty_list: Empty candle list returns None.

    3. Create src/ensemble/loader.py:
       - `load_events(source: Path) -> list[Event]`: Loads a JSON file containing a list of event dicts (or a dict with "events" key), validates each into an Event model, returns list. Raises clear ValueError if validation fails with the event_ticker that failed.
       - Handle both formats: bare list `[{...}, ...]` and wrapped `{"metadata": {...}, "events": [{...}, ...]}`.
       - Parse `window_prices` keys from string labels ("T-7d") to TimeWindowLabel enum.
       - Parse datetime strings with `datetime.fromisoformat()`.

    4. Create data/sample/sample_events.json with 2 realistic sample events for testing the load command:
       - One economics event (e.g., "Fed rate decision Dec 2024"), outcome "yes", window_prices: {"T-7d": 72, "T-1d": 85, "T-1h": 93}
       - One weather event (e.g., "Hurricane landfall prediction"), outcome "no", window_prices: {"T-7d": 35, "T-1d": 28, "T-1h": 15}
       - Include all required Event fields with realistic data. Use ISO 8601 timestamps with UTC timezone.

    5. Create src/ensemble/cli.py:
       - `app = typer.Typer(name="ensemble", help="LLM Prediction Market Ensemble")`
       - `load` command: Takes `source: Path` argument. Calls `load_events(source)`. For each event, generates snapshots for all 3 windows using `event.snapshot(window)`. Prints each EventSnapshot using rich Table (columns: event_ticker, window, question, yes_price, no_price). Shows count of events loaded and snapshots generated.
       - Add `--validate-only` flag that validates without printing the full table (just prints "N events validated successfully").

    6. Run `uv run pytest tests/ -v` and confirm all tests pass.
    7. Run `uv run python -m ensemble load data/sample/sample_events.json` and confirm it prints a formatted table of 6 snapshots (2 events x 3 windows).
  </action>
  <verify>
    `uv run pytest tests/ -v` -- all tests pass (models + slicer).
    `uv run python -m ensemble load data/sample/sample_events.json` -- prints rich table with 6 EventSnapshot rows, no outcome fields visible.
    `uv run python -m ensemble load data/sample/sample_events.json --validate-only` -- prints "2 events validated successfully".
  </verify>
  <done>
    `python -m ensemble load` ingests a JSON file, validates into Event models, generates 3 time window snapshots per event, and prints them in a rich table. No outcome data appears in the output. Slicer correctly computes window timestamps.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -v` -- all tests pass
2. `uv run python -m ensemble load data/sample/sample_events.json` -- prints 6 snapshot rows (2 events x 3 windows) in a rich table
3. `uv run python -c "from ensemble.models import EventSnapshot; print([f for f in EventSnapshot.model_fields])"` -- output contains NO outcome/result/settlement fields
4. `uv run python -m ensemble --help` -- shows available commands
</verification>

<success_criteria>
- Event and EventSnapshot pydantic models exist with composition-based type boundary
- EventSnapshot structurally cannot contain outcome data (verified by test)
- JSON loader parses events file into validated Event models
- Time window slicer computes T-7d, T-1d, T-1h timestamps correctly
- CLI `load` command prints validated snapshots with no outcome leakage
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
